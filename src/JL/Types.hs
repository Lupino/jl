{-# LANGUAGE DeriveDataTypeable #-}
-- |

module JL.Types where

import Control.Exception
import Data.Aeson
import Data.Data
import Data.HashMap.Strict (HashMap)
import Data.Text (Text)
import Data.Typeable
import Text.Parsec.Error

data ParseException
  = TokenizerError ParseError
  | ParserError ParseError
 deriving (Typeable, Show)
instance Exception ParseException

-- | A type.
data Type
  = VariableType !TypeVariable
  | FunctionType !Type !Type
  | ValueType
  deriving (Ord, Eq, Show)

-- | An expression.
data Expression
  = VariableExpression !Variable
  | LambdaExpression !Variable !Type !Expression
  | ValueExpression !Value
  | ApplicationExpression !Expression !Expression
  | InfixExpression !Expression !Variable !Expression
  | IfExpression !Expression !Expression !Expression
  | EvalExpression !(Expression -> Expression)
  | RecordExpression !(HashMap Text Expression)
  | Subscripts !Expression ![Value]

-- | A type variable, generated by the type system.
newtype TypeVariable =
  TypeVariable Int
  deriving (Show, Eq, Ord)

-- | A value variable, inputted by the programmer.
newtype Variable =
  Variable Text
  deriving (Show, Eq, Ord)

data Token
  = If
  | Then
  | Else
  | Case
  | Of
  | Backslash
  | RightArrow
  | Dollar
  | OpenParen
  | CloseParen
  | OpenBracket
  | CloseBracket
  | Equals
  | VariableToken !Text
  | StringToken !Text
  | Operator !Text
  | Period
  | Comma
  | Integer !Integer
  | Decimal !Double
  | OpenBrace
  | CloseBrace
  | Colon
  | NonIndentedNewline
  | Bar
  | TrueToken
  | FalseToken
  | NullToken
  deriving (Eq, Ord, Show)

data Location = Location
  { locationStartLine :: !Int
  , locationStartColumn :: !Int
  , locationEndLine :: !Int
  , locationEndColumn :: !Int
  } deriving (Show, Eq)
